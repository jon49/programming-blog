<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design Patterns on Hamsters Byte</title>
    <link>http://localhost:1313/tags/design-patterns/</link>
    <description>Recent content in Design Patterns on Hamsters Byte</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 20 Jun 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Match Expression for JavaScript?</title>
      <link>http://localhost:1313/2014/06/20/match_expression_javascript/</link>
      <pubDate>Fri, 20 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2014/06/20/match_expression_javascript/</guid>
      <description>&lt;p&gt;Sometimes (or rather most of the time) it would be nice to have more concise code in JavaScript. I was working with a function that needed quite a bit of &lt;code&gt;if&lt;/code&gt; statements. &lt;code&gt;if&lt;/code&gt; was awfully cluttered. I had looked at &lt;a href=&#34;http://bilby.brianmckenna.org/examples/validation.htm&#34;&gt;bilby.js examples&lt;/a&gt; and hadn&amp;rsquo;t realized that you can do multiple &lt;code&gt;ternary expressions&lt;/code&gt; in a row.&lt;/p&gt;

&lt;p&gt;So, instead of,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (0){
  return 0
}
else if (1){
   if (2) {
     return 1
   }
   else if (3) {
     return 2
   }
   else {
     return 3
   }
}
else {
  return 4
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can do,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(0) ? 0
: (1) ?
     (2) ? 1
   : (3) ? 2
   : 3
: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is much more concise and readable.&lt;/p&gt;

&lt;p&gt;So where does &lt;code&gt;match expressions&lt;/code&gt; come into play? Glad you asked.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;ternary&lt;/code&gt; example above gives a similar &lt;a href=&#34;http://fsharpforfunandprofit.com/posts/match-expression/&#34;&gt;feel to &lt;code&gt;F#&lt;/code&gt;&amp;rsquo;s &lt;code&gt;match expressions&lt;/code&gt;&lt;/a&gt;. So, as an example here&amp;rsquo;s what a similary structured &lt;code&gt;match expression&lt;/code&gt; would look like.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;match [something] with 
| pattern0 -&amp;gt; 0
| pattern1 -&amp;gt; 
   match [something else] with
   | pattern2 -&amp;gt; 1
   | pattern3 -&amp;gt; 2
   | _ -&amp;gt; 3
| _ -&amp;gt; 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, with &lt;code&gt;F#&lt;/code&gt; you could probably get away  without doing the second &lt;code&gt;match&lt;/code&gt; by using a &lt;code&gt;Tuple&lt;/code&gt; but that is beyond the scope of this post.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s look at the real function I made. First, let&amp;rsquo;s set up the bare parts of the function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var addRollingArray = function (array, start, end, fraction) {
  var floor = Math.floor
  // Put code below here.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we&amp;rsquo;ll map the array with some helper logic values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  return _.map(array, function (value, index) {
    var isIndexStart = (floor(start) === index),
        isIndexBetween = (floor(start) &amp;lt;= index &amp;amp;&amp;amp; index &amp;lt;= floor(end)),
        isIndexEnd = (floor(end) === index)
    // Code below goes here.
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s the &lt;code&gt;if&lt;/code&gt; code,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (isIndexBetween) {
  if (isIndexStart &amp;amp;&amp;amp; isIndexEnd)
    return fraction * (end - start) + value
  else if (isIndexStart)
    return fraction * (1 + index - start) + value
  else if (isIndexEnd)
    return fraction * (end - index) + value
  else
    // Index is fully between start and end values
    return fraction + value
}
// Index is out of bounds return original value
return value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here&amp;rsquo;s the refactored code,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;return   
  isIndexBetween ? 
      isIndexStart &amp;amp;&amp;amp; isIndexEnd ? fraction * (end - start) + value
    : isIndexStart ? fraction * (1 + index - start) + value
    : isIndexEnd   ? fraction * (end - index) + value
    // Index is fully between start and end values
    : fraction + value
  // Index is out of bounds return original value
  : value
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Prototypes &amp; Compositions with Objects</title>
      <link>http://localhost:1313/2014/06/04/prototypes_composition_with_objects/</link>
      <pubDate>Wed, 04 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2014/06/04/prototypes_composition_with_objects/</guid>
      <description>&lt;p&gt;I was trying to figure out the best way to have functions be both compatible with an object oriented paradigm and a functional oriented paradigm when working on objects. My implementations are probably naive, but instructive nevertheless. It seems that &lt;a href=&#34;http://lodash.com/&#34;&gt;lo-dash&lt;/a&gt; and other libraries have done a good job bridging those worlds.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say you have an object &lt;code&gt;O&lt;/code&gt; such that&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function O(a, b){
  this.a = a
  this.b = b
}

var o = function(a, b){
  return new O(a, b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, you want to &lt;code&gt;extend&lt;/code&gt; the object but you also want the option to use the object in a more fuctional way with &lt;code&gt;compose&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with a simple &lt;code&gt;display&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var display = function(thisArg){
  var o_ = thisArg || this
  console.log(o_)
  return o_
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then a method to change a property.*&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var change = function(property){
  return function(value, thisArg){
  	var o_ = _.cloneDeep(thisArg || this)
    o_[property] = value
    return o_
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can set property to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var changeA = change(&#39;a&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can add &lt;code&gt;changeA&lt;/code&gt; to the &lt;code&gt;O&lt;/code&gt; object and use it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;O.prototype.changeA = changeA
var o_ = o(1, 2)
o_.changeA(3).display()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or we can use a functional approach.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o_ = o(1, 2)
_.compose(display, _.curry(changeA)(3))(o_)
//OR
_.compose(display, _.partialRight(changeA, o_))(3)
//OR
_.compose(display, changeA)(3, o_)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think I like the functional approach for the more abstract functions and the OO approach as your code becomes more specific. The functional evangelists say the functional style is better because it leads to more reusable code. Which I would agree with, since you are not tying your code up with an object you can then easily extend your model to various other objects, without the use of &lt;code&gt;inheritance&lt;/code&gt; and other OO monsters. I think I will use a hybrid approach with &lt;code&gt;bilby.js&lt;/code&gt; library which uses polymorphism.&lt;/p&gt;

&lt;p&gt;By the way, what I just did with &lt;code&gt;change&lt;/code&gt; is similar to &lt;a href=&#34;https://github.com/fantasyland/fantasy-lenses&#34;&gt;&lt;code&gt;lenses&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;* An alternative to this would be using a partial function, which would make the original function more flexible.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var change = function(property, value, thisArg){
  	var o_ = _.cloneDeep(thisArg || this)
    o_[property] = value
    return o_
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can set property to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var changeA = _.partial(change, &#39;a&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using combinators (not strict).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var set = function(property, value){
  this[property] = value
  return this
}

var change = function(f, value, thisArg){
  	var o_ = _.cloneDeep(thisArg || this)
    o_ = f.apply(o_, [value])
    return o_
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can set property to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var changeA = _.partial(change
              , _.partial(set, &#39;a&#39;))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Notes on Monads, Monoids, and Make Believe</title>
      <link>http://localhost:1313/2014/05/15/monads_monoids_and_make_believe_brian_lonsdorf/</link>
      <pubDate>Thu, 15 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/2014/05/15/monads_monoids_and_make_believe_brian_lonsdorf/</guid>
      <description>

&lt;h2 id=&#34;with-brian-lonsdorf:0ca8684476f81d878f3c655714614cce&#34;&gt;with Brian Lonsdorf&lt;/h2&gt;

&lt;h3 id=&#34;working-with-objects:0ca8684476f81d878f3c655714614cce&#34;&gt;Working with Objects&lt;/h3&gt;

&lt;h4 id=&#34;the-better-way:0ca8684476f81d878f3c655714614cce&#34;&gt;the better way&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var SSN = Constructor(function(number, current_user){
	this.number = number
    this.user = current_user
})

SSN.prototype = {
	fmap: function(f){
    	if(this.user.is_admin)
        	return SSN(f(this.number), this.user)
    }
}

social.fmap(replace(&#39;-&#39;, &#39;&#39;))
//=&amp;gt; SSN(&#39;123456789&#39;, user)

social.fmap(function(number){return number.reverse()})
//=&amp;gt; SSN(&#39;1234-56-789&#39;, user)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-functor-way:0ca8684476f81d878f3c655714614cce&#34;&gt;the functor way&lt;/h4&gt;

&lt;p&gt;Note: &lt;a href=&#34;https://github.com/DrBoolean/Functor/blob/master/functor.js&#34;&gt;Functor function defined.&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var AdminAccess = Constructor(function(val, current_user){
	this.val = val
    this.user = current_user
})

Functor(AdminAccess, {
	fmap: function(f){
    	if(this.user.is_admin)
        	return AdminAccess(f(this.val), this.user)
    }
})

var social = AdminAccess(&#39;1234-56-789&#39;, current_user)
fmap(removeDashes, social)
//=&amp;gt; AdminAccess(&#39;123456789&#39;, current_user)
fmap(validNumber, social)
//=&amp;gt; AdminAccess(true, current_user)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;He then goes into other useful patterns with monads. But I&amp;rsquo;ll revisit that later after I get a better handle on this!&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;//www.youtube.com/embed/ww2Z1URx-G0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
  </channel>
</rss>